#include <SDL2/SDL.h>
#include <vector>
#include <cstdlib>
#include <ctime>

const int SCREEN_WIDTH = 800;
const int SCREEN_HEIGHT = 600;
const int GRID_SIZE = 20;
const int SNAKE_SPEED = 150;

struct Point {
    int x, y;
};

class SnakeGame {
private:
    SDL_Window* window;
    SDL_Renderer* renderer;
    std::vector<Point> snake;
    Point apple;
    Point rocket;
    int score;
    bool running;
    bool gameOver;
    int dirX, dirY;
    bool rocketActive;

public:
    SnakeGame() {
        SDL_Init(SDL_INIT_VIDEO);
        window = SDL_CreateWindow("Snake Game", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);
        renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
        resetGame();
    }

    ~SnakeGame() {
        SDL_DestroyRenderer(renderer);
        SDL_DestroyWindow(window);
        SDL_Quit();
    }

    void resetGame() {
        snake = {{SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2}};
        apple = {rand() % (SCREEN_WIDTH / GRID_SIZE) * GRID_SIZE, rand() % (SCREEN_HEIGHT / GRID_SIZE) * GRID_SIZE};
        rocketActive = false;
        score = 0;
        running = true;
        gameOver = false;
        dirX = GRID_SIZE;
        dirY = 0;
    }

    void spawnRocket() {
        rocket.x = rand() % (SCREEN_WIDTH / GRID_SIZE) * GRID_SIZE;
        rocket.y = 0;
        rocketActive = true;
    }

    void handleEvents() {
        SDL_Event event;
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT) {
                running = false;
            } else if (event.type == SDL_MOUSEMOTION) {
                int mouseX = event.motion.x;
                int mouseY = event.motion.y;
                if (abs(mouseX - snake[0].x) > abs(mouseY - snake[0].y)) {
                    dirX = (mouseX > snake[0].x) ? GRID_SIZE : -GRID_SIZE;
                    dirY = 0;
                } else {
                    dirX = 0;
                    dirY = (mouseY > snake[0].y) ? GRID_SIZE : -GRID_SIZE;
                }
            }
        }
    }

    void update() {
        if (gameOver) return;
        
        Point newHead = {snake[0].x + dirX, snake[0].y + dirY};
        
        if (newHead.x < 0 || newHead.x >= SCREEN_WIDTH || newHead.y < 0 || newHead.y >= SCREEN_HEIGHT) {
            gameOver = true;
            return;
        }
        
        for (auto& segment : snake) {
            if (segment.x == newHead.x && segment.y == newHead.y) {
                gameOver = true;
                return;
            }
        }
        
        snake.insert(snake.begin(), newHead);
        
        if (newHead.x == apple.x && newHead.y == apple.y) {
            apple = {rand() % (SCREEN_WIDTH / GRID_SIZE) * GRID_SIZE, rand() % (SCREEN_HEIGHT / GRID_SIZE) * GRID_SIZE};
            score++;
        } else {
            snake.pop_back();
        }
        
        if (!rocketActive && rand() % 100 < 2) {
            spawnRocket();
        }
        
        if (rocketActive) {
            rocket.y += 5;
            if (rocket.y >= SCREEN_HEIGHT) {
                rocketActive = false;
            }
            if (newHead.x == rocket.x && newHead.y == rocket.y) {
                gameOver = true;
            }
        }
    }

    void render() {
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        SDL_RenderClear(renderer);

        SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
        for (auto& segment : snake) {
            SDL_Rect rect = {segment.x, segment.y, GRID_SIZE, GRID_SIZE};
            SDL_RenderFillRect(renderer, &rect);
        }

        SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        SDL_Rect appleRect = {apple.x, apple.y, GRID_SIZE, GRID_SIZE};
        SDL_RenderFillRect(renderer, &appleRect);

        if (rocketActive) {
            SDL_SetRenderDrawColor(renderer, 255, 255, 0, 255);
            SDL_Rect rocketRect = {rocket.x, rocket.y, GRID_SIZE, GRID_SIZE};
            SDL_RenderFillRect(renderer, &rocketRect);
        }

        SDL_RenderPresent(renderer);
    }

    void gameOverBlink() {
        for (int i = 0; i < 6; i++) {
            SDL_SetRenderDrawColor(renderer, (i % 2) ? 255 : 0, 0, 0, 255);
            SDL_RenderClear(renderer);
            SDL_RenderPresent(renderer);
            SDL_Delay(300);
        }
    }

    void run() {
        while (running) {
            handleEvents();
            update();
            render();
            if (gameOver) {
                gameOverBlink();
                SDL_Delay(2000);
                resetGame();
            }
            SDL_Delay(SNAKE_SPEED);
        }
    }
};

int main() {
    srand(time(0));
    SnakeGame game;
    game.run();
    return 0;
}